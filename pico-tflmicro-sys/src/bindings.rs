/* automatically generated by rust-bindgen 0.63.0 */

# [allow (non_snake_case , non_camel_case_types , non_upper_case_globals)] pub mod root { # [repr (C)] # [derive (Default)] pub struct __IncompleteArrayField < T > (:: core :: marker :: PhantomData < T > , [T ; 0]) ; impl < T > __IncompleteArrayField < T > { # [inline] pub const fn new () -> Self { __IncompleteArrayField (:: core :: marker :: PhantomData , []) } # [inline] pub fn as_ptr (& self) -> * const T { self as * const _ as * const T } # [inline] pub fn as_mut_ptr (& mut self) -> * mut T { self as * mut _ as * mut T } # [inline] pub unsafe fn as_slice (& self , len : usize) -> & [T] { :: core :: slice :: from_raw_parts (self . as_ptr () , len) } # [inline] pub unsafe fn as_mut_slice (& mut self , len : usize) -> & mut [T] { :: core :: slice :: from_raw_parts_mut (self . as_mut_ptr () , len) } } impl < T > :: core :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt (& self , fmt : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { fmt . write_str ("__IncompleteArrayField") } } # [allow (unused_imports)] use self :: super :: root ; pub mod std { # [allow (unused_imports)] use self :: super :: super :: root ; } pub mod __gnu_cxx { # [allow (unused_imports)] use self :: super :: super :: root ; } pub mod flatbuffers { # [allow (unused_imports)] use self :: super :: super :: root ; } # [doc = " Success"] pub const kTfLiteOk : root :: TfLiteStatus = 0 ; # [doc = " Generally referring to an error in the runtime (i.e. interpreter)"] pub const kTfLiteError : root :: TfLiteStatus = 1 ; # [doc = " Generally referring to an error from a TfLiteDelegate itself."] pub const kTfLiteDelegateError : root :: TfLiteStatus = 2 ; # [doc = " Generally referring to an error in applying a delegate due to\n incompatibility between runtime and delegate, e.g., this error is returned\n when trying to apply a TF Lite delegate onto a model graph that's already\n immutable."] pub const kTfLiteApplicationError : root :: TfLiteStatus = 3 ; # [doc = " Generally referring to serialized delegate data not being found.\n See tflite::delegates::Serialization."] pub const kTfLiteDelegateDataNotFound : root :: TfLiteStatus = 4 ; # [doc = " Generally referring to data-writing issues in delegate serialization.\n See tflite::delegates::Serialization."] pub const kTfLiteDelegateDataWriteError : root :: TfLiteStatus = 5 ; # [doc = " Generally referring to data-reading issues in delegate serialization.\n See tflite::delegates::Serialization."] pub const kTfLiteDelegateDataReadError : root :: TfLiteStatus = 6 ; # [doc = " Generally referring to issues when the TF Lite model has ops that cannot\n be resolved at runtime. This could happen when the specific op is not\n registered or built with the TF Lite framework."] pub const kTfLiteUnresolvedOps : root :: TfLiteStatus = 7 ; # [doc = " Generally referring to invocation cancelled by the user.\n See `interpreter::Cancel`."] pub const kTfLiteCancelled : root :: TfLiteStatus = 8 ; # [doc = " Note that new error status values may be added in future in order to\n indicate more fine-grained internal states, therefore, applications should\n not rely on status values being members of the enum."] pub type TfLiteStatus = cty :: c_uint ; pub const kTfLiteNoType : root :: TfLiteType = 0 ; pub const kTfLiteFloat32 : root :: TfLiteType = 1 ; pub const kTfLiteInt32 : root :: TfLiteType = 2 ; pub const kTfLiteUInt8 : root :: TfLiteType = 3 ; pub const kTfLiteInt64 : root :: TfLiteType = 4 ; pub const kTfLiteString : root :: TfLiteType = 5 ; pub const kTfLiteBool : root :: TfLiteType = 6 ; pub const kTfLiteInt16 : root :: TfLiteType = 7 ; pub const kTfLiteComplex64 : root :: TfLiteType = 8 ; pub const kTfLiteInt8 : root :: TfLiteType = 9 ; pub const kTfLiteFloat16 : root :: TfLiteType = 10 ; pub const kTfLiteFloat64 : root :: TfLiteType = 11 ; pub const kTfLiteComplex128 : root :: TfLiteType = 12 ; pub const kTfLiteUInt64 : root :: TfLiteType = 13 ; pub const kTfLiteResource : root :: TfLiteType = 14 ; pub const kTfLiteVariant : root :: TfLiteType = 15 ; pub const kTfLiteUInt32 : root :: TfLiteType = 16 ; pub const kTfLiteUInt16 : root :: TfLiteType = 17 ; pub const kTfLiteInt4 : root :: TfLiteType = 18 ; # [doc = " Types supported by tensor"] pub type TfLiteType = cty :: c_uint ; # [doc = " Legacy. Will be deprecated in favor of `TfLiteAffineQuantization`.\n If per-layer quantization is specified this field will still be populated in\n addition to `TfLiteAffineQuantization`.\n Parameters for asymmetric quantization. Quantized values can be converted\n back to float using: `real_value = scale * (quantized_value - zero_point)`"] # [repr (C)] # [derive (Debug , Default , Copy , Clone , PartialEq)] pub struct TfLiteQuantizationParams { pub scale : f32 , pub zero_point : i32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct TfLiteOpaqueContext { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct TfLiteOpaqueTensor { _unused : [u8 ; 0] , } # [doc = " WARNING: This is an experimental interface that is subject to change."] pub type TfLiteOpaqueDelegate = root :: TfLiteDelegate ; pub const kTfLiteEigenContext : root :: TfLiteExternalContextType = 0 ; # [doc = " include eigen_support.h to use."] pub const kTfLiteGemmLowpContext : root :: TfLiteExternalContextType = 1 ; # [doc = " include gemm_support.h to use."] pub const kTfLiteEdgeTpuContext : root :: TfLiteExternalContextType = 2 ; # [doc = " Placeholder for Edge TPU support."] pub const kTfLiteCpuBackendContext : root :: TfLiteExternalContextType = 3 ; # [doc = " include cpu_backend_context.h to use."] pub const kTfLiteMaxExternalContexts : root :: TfLiteExternalContextType = 4 ; # [doc = " The list of external context types known to TF Lite. This list exists solely\n to avoid conflicts and to ensure ops can share the external contexts they\n need. Access to the external contexts is controlled by one of the\n corresponding support files."] pub type TfLiteExternalContextType = cty :: c_uint ; # [doc = " An external context is a collection of information unrelated to the TF Lite\n framework, but useful to a subset of the ops. TF Lite knows very little\n about the actual contexts, but it keeps a list of them, and is able to\n refresh them if configurations like the number of recommended threads\n change."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteExternalContext { pub type_ : root :: TfLiteExternalContextType , pub Refresh : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext) -> root :: TfLiteStatus > , } impl Default for TfLiteExternalContext { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " Fixed size list of integers. Used for dimensions and inputs/outputs tensor\n indices"] # [repr (C)] # [derive (Debug , Default)] pub struct TfLiteIntArray { pub size : cty :: c_int , pub data : root :: __IncompleteArrayField < cty :: c_int > , } # [doc = " Single-precision complex data type compatible with the C99 definition."] # [repr (C)] # [derive (Debug , Default , Copy , Clone , PartialEq)] pub struct TfLiteComplex64 { pub re : f32 , pub im : f32 , } # [doc = " Double-precision complex data type compatible with the C99 definition."] # [repr (C)] # [derive (Debug , Default , Copy , Clone , PartialEq)] pub struct TfLiteComplex128 { pub re : f64 , pub im : f64 , } # [doc = " Half precision data type compatible with the C99 definition."] # [repr (C)] # [derive (Debug , Default , Copy , Clone , PartialEq , Eq)] pub struct TfLiteFloat16 { pub data : u16 , } # [doc = " No quantization."] pub const kTfLiteNoQuantization : root :: TfLiteQuantizationType = 0 ; # [doc = " Affine quantization (with support for per-channel quantization).\n Corresponds to TfLiteAffineQuantization."] pub const kTfLiteAffineQuantization : root :: TfLiteQuantizationType = 1 ; # [doc = " SupportedQuantizationTypes."] pub type TfLiteQuantizationType = cty :: c_uint ; # [doc = " Structure specifying the quantization used by the tensor, if-any."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteQuantization { # [doc = " The type of quantization held by params."] pub type_ : root :: TfLiteQuantizationType , # [doc = " Holds an optional reference to a quantization param structure. The actual\n type depends on the value of the `type` field (see the comment there for\n the values and corresponding types)."] pub params : * mut cty :: c_void , } impl Default for TfLiteQuantization { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " A union of pointers that points to memory for a given tensor.\n\n Do not access these members directly, if possible, use\n `GetTensorData<TYPE>(tensor)` instead, otherwise only access `.data`, as\n other members are deprecated."] # [repr (C)] # [derive (Copy , Clone)] pub union TfLitePtrUnion { pub i32_ : * mut i32 , pub u32_ : * mut u32 , pub i64_ : * mut i64 , pub u64_ : * mut u64 , pub f : * mut f32 , pub f16 : * mut root :: TfLiteFloat16 , pub f64_ : * mut f64 , pub raw : * mut cty :: c_char , pub raw_const : * const cty :: c_char , pub uint8 : * mut u8 , pub b : * mut bool , pub i16_ : * mut i16 , pub ui16 : * mut u16 , pub c64 : * mut root :: TfLiteComplex64 , pub c128 : * mut root :: TfLiteComplex128 , pub int8 : * mut i8 , # [doc = " Only use this member."] pub data : * mut cty :: c_void , } impl Default for TfLitePtrUnion { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } impl :: core :: fmt :: Debug for TfLitePtrUnion { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "TfLitePtrUnion {{ union }}") } } pub const kTfLiteMemNone : root :: TfLiteAllocationType = 0 ; pub const kTfLiteMmapRo : root :: TfLiteAllocationType = 1 ; pub const kTfLiteArenaRw : root :: TfLiteAllocationType = 2 ; pub const kTfLiteArenaRwPersistent : root :: TfLiteAllocationType = 3 ; pub const kTfLiteDynamic : root :: TfLiteAllocationType = 4 ; pub const kTfLitePersistentRo : root :: TfLiteAllocationType = 5 ; pub const kTfLiteCustom : root :: TfLiteAllocationType = 6 ; pub const kTfLiteVariantObject : root :: TfLiteAllocationType = 7 ; # [doc = " Memory allocation strategies.\n  * `kTfLiteMmapRo`: Read-only memory-mapped data, or data externally\n        allocated.\n  * `kTfLiteArenaRw`: Arena allocated with no guarantees about persistence,\n        and available during eval.\n  * `kTfLiteArenaRwPersistent`: Arena allocated but persistent across eval,\n  and only available during eval.\n  * `kTfLiteDynamic`: Allocated during eval, or for string tensors.\n  * `kTfLitePersistentRo`: Allocated and populated during prepare. This is\n        useful for tensors that can be computed during prepare and treated\n        as constant inputs for downstream ops (also in prepare).\n  * `kTfLiteCustom`: Custom memory allocation provided by the user. See\n        TfLiteCustomAllocation below.\n  * `kTfLiteVariantObject`: Allocation is an arbitrary type-erased C++\n  object.\n        Allocation and deallocation are done through `new` and `delete`."] pub type TfLiteAllocationType = cty :: c_uint ; # [doc = " The delegates should use zero or positive integers to represent handles.\n -1 is reserved from unallocated status."] pub type TfLiteBufferHandle = cty :: c_int ; # [repr (C)] # [derive (Copy , Clone)] pub struct TfLiteTensor { pub quantization : root :: TfLiteQuantization , pub params : root :: TfLiteQuantizationParams , pub data : root :: TfLitePtrUnion , pub dims : * mut root :: TfLiteIntArray , pub bytes : usize , pub type_ : root :: TfLiteType , pub allocation_type : root :: TfLiteAllocationType , pub is_variable : bool , } impl Default for TfLiteTensor { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } impl :: core :: fmt :: Debug for TfLiteTensor { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "TfLiteTensor {{ quantization: {:?}, params: {:?}, data: {:?}, dims: {:?}, type: {:?}, allocation_type: {:?}, is_variable: {:?} }}" , self . quantization , self . params , self . data , self . dims , self . type_ , self . allocation_type , self . is_variable) } } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteNode { pub inputs : * mut root :: TfLiteIntArray , pub outputs : * mut root :: TfLiteIntArray , pub intermediates : * mut root :: TfLiteIntArray , pub user_data : * mut cty :: c_void , pub builtin_data : * mut cty :: c_void , pub custom_initial_data : * const cty :: c_void , pub custom_initial_data_size : cty :: c_int , } impl Default for TfLiteNode { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " Light-weight tensor struct for TF Micro runtime. Provides the minimal amount\n of information required for a kernel to run during TfLiteRegistration::Eval."] # [repr (C)] # [derive (Copy , Clone)] pub struct TfLiteEvalTensor { # [doc = " A union of data pointers. The appropriate type should be used for a typed\n tensor based on `type`."] pub data : root :: TfLitePtrUnion , # [doc = " A pointer to a structure representing the dimensionality interpretation\n that the buffer should have."] pub dims : * mut root :: TfLiteIntArray , # [doc = " The data type specification for data stored in `data`. This affects\n what member of `data` union should be used."] pub type_ : root :: TfLiteType , } impl Default for TfLiteEvalTensor { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } impl :: core :: fmt :: Debug for TfLiteEvalTensor { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "TfLiteEvalTensor {{ data: {:?}, dims: {:?}, type: {:?} }}" , self . data , self . dims , self . type_) } } # [doc = " WARNING: This is an experimental interface that is subject to change.\n\n Currently, TfLiteDelegateParams has to be allocated in a way that it's\n trivially destructable. It will be stored as `builtin_data` field in\n `TfLiteNode` of the delegate node.\n\n See also the `CreateDelegateParams` function in `interpreter.cc` details."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteDelegateParams { pub delegate : * mut root :: TfLiteDelegate , pub nodes_to_replace : * mut root :: TfLiteIntArray , pub input_tensors : * mut root :: TfLiteIntArray , pub output_tensors : * mut root :: TfLiteIntArray , } impl Default for TfLiteDelegateParams { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " `TfLiteContext` allows an op to access the tensors.\n\n `TfLiteContext` is a struct that is created by the TF Lite runtime\n and passed to the \"methods\" (C function pointers) in the\n `TfLiteRegistration` struct that are used to define custom ops and custom\n delegate kernels. It contains information and methods (C function pointers)\n that can be called by the code implementing a custom op or a custom delegate\n kernel. These methods provide access to the context in which that custom op\n or custom delegate kernel occurs, such as access to the input and output\n tensors for that op, as well as methods for allocating memory buffers\n and intermediate tensors, etc.\n\n See also `TfLiteOpaqueContext`, which is an more ABI-stable equivalent."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteContext { # [doc = " Number of tensors in the context."] pub tensors_size : usize , # [doc = " The execution plan contains a list of the node indices in execution\n order. execution_plan->size is the current number of nodes. And,\n execution_plan->data[0] is the first node that needs to be run.\n TfLiteDelegates can traverse the current execution plan by iterating\n through each member of this array and using GetNodeAndRegistration() to\n access details about a node. i.e.\n\n\n     TfLiteIntArray* execution_plan;\n     TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context,\n                                                     &execution_plan));\n     for (int exec_index = 0; exec_index < execution_plan->size;\n           exec_index++) {\n        int node_index = execution_plan->data[exec_index];\n        TfLiteNode* node;\n        TfLiteRegistration* reg;\n        context->GetNodeAndRegistration(context, node_index, &node, &reg);\n     }\n\n Note: the memory pointed by '`*execution_plan` is OWNED by TfLite runtime.\n Future calls to GetExecutionPlan invalidates earlier outputs. The\n following code snippet shows the issue of such an invocation pattern.\n After calling CheckNode, subsequent access to `plan_1st` is undefined.\n\n     void CheckNode(const TfLiteNode* node) {\n       ...\n       TfLiteIntArray* plan_2nd;\n       TF_LITE_ENSURE_STATUS(\n           context->GetExecutionPlan(context, &plan_2nd)\n       );\n       ...\n     }\n\n     TfLiteIntArray* plan_1st;\n     TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context, &plan_1st));\n     for (int exec_index = 0; exec_index < plan_1st->size; exec_index++) {\n        int node_index = plan_1st->data[exec_index];\n        TfLiteNode* node;\n        TfLiteRegistration* reg;\n        context->GetNodeAndRegistration(context, node_index, &node, &reg);\n        CheckNode(node);\n     }\n\n WARNING: This is an experimental interface that is subject to change."] pub GetExecutionPlan : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , execution_plan : * mut * mut root :: TfLiteIntArray) -> root :: TfLiteStatus > , # [doc = " An array of tensors in the interpreter context (of length `tensors_size`)"] pub tensors : * mut root :: TfLiteTensor , # [doc = " opaque full context ptr (an opaque c++ data structure)"] pub impl_ : * mut cty :: c_void , # [doc = " Request memory pointer be resized. Updates dimensions on the tensor.\n NOTE: ResizeTensor takes ownership of newSize."] pub ResizeTensor : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , tensor : * mut root :: TfLiteTensor , new_size : * mut root :: TfLiteIntArray) -> root :: TfLiteStatus > , # [doc = " Request that an error be reported with format string msg."] pub ReportError : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , msg : * const cty :: c_char , ...) > , # [doc = " Add `tensors_to_add` tensors, preserving pre-existing Tensor entries.  If\n non-null, the value pointed to by `first_new_tensor_index` will be set to\n the index of the first new tensor."] pub AddTensors : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , tensors_to_add : cty :: c_int , first_new_tensor_index : * mut cty :: c_int) -> root :: TfLiteStatus > , # [doc = " Get a Tensor node by node_index.\n\n WARNING: This is an experimental interface that is subject to change."] pub GetNodeAndRegistration : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , node_index : cty :: c_int , node : * mut * mut root :: TfLiteNode , registration : * mut * mut root :: TfLiteRegistration) -> root :: TfLiteStatus > , # [doc = " Replace ops with one or more stub delegate operations. This function\n does not take ownership of `nodes_to_replace`."] pub ReplaceNodeSubsetsWithDelegateKernels : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , registration : root :: TfLiteRegistration , nodes_to_replace : * const root :: TfLiteIntArray , delegate : * mut root :: TfLiteDelegate) -> root :: TfLiteStatus > , # [doc = " Number of threads that are recommended to subsystems like gemmlowp and\n eigen."] pub recommended_num_threads : cty :: c_int , # [doc = " Access external contexts by type.\n\n WARNING: This is an experimental interface that is subject to change."] pub GetExternalContext : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , arg2 : root :: TfLiteExternalContextType) -> * mut root :: TfLiteExternalContext > , # [doc = " Set the value of a external context. Does not take ownership of the\n pointer.\n\n WARNING: This is an experimental interface that is subject to change."] pub SetExternalContext : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut root :: TfLiteContext , arg2 : root :: TfLiteExternalContextType , arg3 : * mut root :: TfLiteExternalContext) > , # [doc = " Flag for allowing float16 precision for FP32 calculation.\n default: false.\n\n WARNING: This is an experimental API and subject to change."] pub allow_fp32_relax_to_fp16 : bool , # [doc = " Pointer to the op-level profiler, if set; nullptr otherwise."] pub profiler : * mut cty :: c_void , # [doc = " Allocate persistent buffer which has the same life time as the\n interpreter. Returns `nullptr` on failure. The memory is allocated from\n heap for TFL, and from tail in TFLM. This method is only available in\n `Init` or `Prepare` stage.\n\n WARNING: This is an experimental interface that is subject\n to change."] pub AllocatePersistentBuffer : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut root :: TfLiteContext , bytes : usize) -> * mut cty :: c_void > , # [doc = " Allocate a buffer which will be deallocated right after invoke phase.\n The memory is allocated from heap in TFL, and from volatile arena in TFLM.\n This method is only available in invoke stage.\n\n NOTE: If possible use `RequestScratchBufferInArena` method to avoid memory\n allocation during inference time.\n\n WARNING: This is an experimental interface that is subject to change."] pub AllocateBufferForEval : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut root :: TfLiteContext , bytes : usize , ptr : * mut * mut cty :: c_void) -> root :: TfLiteStatus > , # [doc = " Request a scratch buffer in the arena through static memory planning.\n This method is only available in `Prepare` stage and the buffer is\n allocated by the interpreter between Prepare and Eval stage. In `Eval`\n stage, `GetScratchBuffer` API can be used to fetch the address.\n\n WARNING: This is an experimental interface that is subject to change."] pub RequestScratchBufferInArena : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut root :: TfLiteContext , bytes : usize , buffer_idx : * mut cty :: c_int) -> root :: TfLiteStatus > , # [doc = " Get the scratch buffer pointer.\n This method is only available in Eval stage.\n\n WARNING: This is an experimental interface that is subject to change."] pub GetScratchBuffer : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut root :: TfLiteContext , buffer_idx : cty :: c_int) -> * mut cty :: c_void > , # [doc = " Resize the memory pointer of the `tensor`. This method behaves the same as\n `ResizeTensor`, except that it makes a copy of the shape array internally\n so the shape array could be deallocated right afterwards.\n\n WARNING: This is an experimental interface that is subject to change."] pub ResizeTensorExplicit : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut root :: TfLiteContext , tensor : * mut root :: TfLiteTensor , dims : cty :: c_int , shape : * const cty :: c_int) -> root :: TfLiteStatus > , # [doc = " This method provides a preview of post-delegation partitioning. Each\n TfLiteDelegateParams in the referenced array corresponds to one instance\n of the delegate kernel. Example usage:\n\n     TfLiteIntArray* nodes_to_replace = ...;\n     TfLiteDelegateParams* params_array;\n     int num_partitions = 0;\n     TF_LITE_ENSURE_STATUS(context->PreviewDelegatePartitioning(\n        context, delegate, nodes_to_replace, &params_array,\n        &num_partitions));\n     for (int idx = 0; idx < num_partitions; idx++) {\n        const auto& partition_params = params_array[idx];\n        ...\n     }\n\n NOTE: The context owns the memory referenced by partition_params_array. It\n will be cleared with another call to PreviewDelegatePartitioning, or after\n TfLiteDelegateParams::Prepare returns.\n\n WARNING: This is an experimental interface that is subject to change."] pub PreviewDelegatePartitioning : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , nodes_to_replace : * const root :: TfLiteIntArray , partition_params_array : * mut * mut root :: TfLiteDelegateParams , num_partitions : * mut cty :: c_int) -> root :: TfLiteStatus > , # [doc = " Returns a TfLiteTensor struct for a given index.\n\n WARNING: This is an experimental interface that is subject to change.\n\n WARNING: This method may not be available on all platforms."] pub GetTensor : :: core :: option :: Option < unsafe extern "C" fn (context : * const root :: TfLiteContext , tensor_idx : cty :: c_int) -> * mut root :: TfLiteTensor > , # [doc = " Returns a TfLiteEvalTensor struct for a given index.\n\n WARNING: This is an experimental interface that is subject to change.\n\n WARNING: This method may not be available on all platforms."] pub GetEvalTensor : :: core :: option :: Option < unsafe extern "C" fn (context : * const root :: TfLiteContext , tensor_idx : cty :: c_int) -> * mut root :: TfLiteEvalTensor > , # [doc = " Retrieves named metadata buffer from the TFLite model.\n Returns kTfLiteOk if metadata is successfully obtained from the flatbuffer\n Model: that is, there exists a `metadata` entry with given `name` string.\n (see TFLite's schema.fbs).\n The corresponding `buffer` information is populated in `ptr` & `bytes`.\n The data from `ptr` is valid for the lifetime of the Interpreter.\n\n WARNING: This is an experimental interface that is subject to change."] pub GetModelMetadata : :: core :: option :: Option < unsafe extern "C" fn (context : * const root :: TfLiteContext , name : * const cty :: c_char , ptr : * mut * const cty :: c_char , bytes : * mut usize) -> root :: TfLiteStatus > , # [doc = " Retrieves the corresponding TfLiteContext of a subgraph that the given\n subgraph_index points to and switches to the delegate context for that\n subgraph. If an invalid subgraph index is given, returns kTfLiteError.\n\n NOTE: This function is expected to be paired with ReleaseSubgraphContext()\n once the delegate preparation is done and/or the delegate context\n functions are no longer needed.\n\n WARNING: This is an experimental interface that is subject to change."] pub AcquireSubgraphContext : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , subgraph_index : cty :: c_int , acquired_context : * mut * mut root :: TfLiteContext) -> root :: TfLiteStatus > , # [doc = " Releases the subgraph context by switching back to the TFLite kernel\n context for the subgraph that the given subgraph_index points to.\n\n NOTE: This function is expected to be used after AcquireSubgraphContext()\n once the delegate preparation is done and/or the delegate context\n functions are no longer needed.\n\n WARNING: This is an experimental interface that is subject to change."] pub ReleaseSubgraphContext : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , subgraph_index : cty :: c_int) -> root :: TfLiteStatus > , } impl Default for TfLiteContext { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct TfLiteRegistrationExternal { _unused : [u8 ; 0] , } # [doc = " `TfLiteRegistration` defines the implementation of an operation\n (a built-in op, custom op, or custom delegate kernel).\n\n It is a struct containing \"methods\" (C function pointers) that will be\n invoked by the TF Lite runtime to evaluate instances of the operation.\n\n See also `TfLiteRegistrationExternal` which is a more ABI-stable equivalent."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteRegistration { # [doc = " Initializes the op from serialized data.\n Called only *once* for the lifetime of the op, so any one-time allocations\n should be made here (unless they depend on tensor sizes).\n\n * If a built-in op:\n       * `buffer` is the op's params data (TfLiteLSTMParams*).\n       * `length` is zero.\n * If custom op:\n       * `buffer` is the op's `custom_options`.\n       * `length` is the size of the buffer.\n\n Returns a type-punned (i.e. void*) opaque data (e.g. a primitive pointer\n or an instance of a struct).\n\n The returned pointer will be stored with the node in the `user_data`\n field, accessible within prepare and invoke functions below.\n\n NOTE: if the data is already in the desired format, simply implement this\n function to return `nullptr` and implement the free function to be a\n no-op."] pub init : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , buffer : * const cty :: c_char , length : usize) -> * mut cty :: c_void > , # [doc = " The pointer `buffer` is the data previously returned by an init\n invocation."] pub free : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , buffer : * mut cty :: c_void) > , # [doc = " prepare is called when the inputs this node depends on have been resized.\n `context->ResizeTensor()` can be called to request output tensors to be\n resized.\n Can be called multiple times for the lifetime of the op.\n\n Returns `kTfLiteOk` on success."] pub prepare : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , node : * mut root :: TfLiteNode) -> root :: TfLiteStatus > , # [doc = " Execute the node (should read `node->inputs` and output to\n `node->outputs`).\n\n Returns `kTfLiteOk` on success."] pub invoke : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , node : * mut root :: TfLiteNode) -> root :: TfLiteStatus > , # [doc = " `profiling_string` is called during summarization of profiling information\n in order to group executions together. Providing a value here will cause a\n given op to appear multiple times is the profiling report. This is\n particularly useful for custom ops that can perform significantly\n different calculations depending on their `user-data`."] pub profiling_string : :: core :: option :: Option < unsafe extern "C" fn (context : * const root :: TfLiteContext , node : * const root :: TfLiteNode) -> * const cty :: c_char > , # [doc = " Builtin codes. If this kernel refers to a builtin this is the code\n of the builtin. This is so we can do marshaling to other frameworks like\n NN API.\n\n Note: It is the responsibility of the registration binder to set this\n properly."] pub builtin_code : i32 , # [doc = " Custom op name. If the op is a builtin, this will be `null`.\n\n Note: It is the responsibility of the registration binder to set this\n properly.\n\n WARNING: This is an experimental interface that is subject to change."] pub custom_name : * const cty :: c_char , # [doc = " The version of the op.\n Note: It is the responsibility of the registration binder to set this\n properly."] pub version : cty :: c_int , # [doc = " The external version of `TfLiteRegistration`. Since we can't use internal\n types (such as `TfLiteContext`) for C API to maintain ABI stability.\n C API user will provide `TfLiteRegistrationExternal` to implement custom\n ops. We keep it inside of `TfLiteRegistration` and use it to route\n callbacks properly."] pub registration_external : * mut root :: TfLiteRegistrationExternal , # [doc = " Retrieves asynchronous kernel.\n\n If the `async_kernel` field is nullptr, it means the operation described\n by this TfLiteRegistration object does not support asynchronous execution.\n Otherwise, the function that the field points to should only be called for\n delegate kernel nodes, i.e. `node` should be a delegate kernel node\n created by applying a delegate. If the function returns nullptr, that\n means that the underlying delegate does not support asynchronous execution\n for this `node`."] pub async_kernel : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , node : * mut root :: TfLiteNode) -> * mut root :: TfLiteAsyncKernel > , # [doc = " Indicates if an operator's output may safely overwrite its inputs.\n See the comments in `TfLiteInPlaceOp`."] pub inplace_operator : u64 , } impl Default for TfLiteRegistration { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " WARNING: This is an experimental interface that is subject to change."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteDelegate { # [doc = " Data that delegate needs to identify itself. This data is owned by the\n delegate. The delegate is owned in the user code, so the delegate is\n responsible for deallocating this when it is destroyed."] pub data_ : * mut cty :: c_void , # [doc = " Invoked by `ModifyGraphWithDelegate`. This prepare is called, giving the\n delegate a view of the current graph through `TfLiteContext*`. It\n typically will look at the nodes and call\n `ReplaceNodeSubsetsWithDelegateKernels()` to ask the TensorFlow lite\n runtime to create macro-nodes to represent delegated subgraphs of the\n original graph."] pub Prepare : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , delegate : * mut root :: TfLiteDelegate) -> root :: TfLiteStatus > , # [doc = " Copy the data from delegate buffer handle into raw memory of the given\n `tensor`. Note that the delegate is allowed to allocate the raw bytes as\n long as it follows the rules for `kTfLiteDynamic` tensors, in which case\n this cannot be null."] pub CopyFromBufferHandle : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , delegate : * mut root :: TfLiteDelegate , buffer_handle : root :: TfLiteBufferHandle , tensor : * mut root :: TfLiteTensor) -> root :: TfLiteStatus > , # [doc = " Copy the data from raw memory of the given `tensor` to delegate buffer\n handle. This can be null if the delegate doesn't use its own buffer."] pub CopyToBufferHandle : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , delegate : * mut root :: TfLiteDelegate , buffer_handle : root :: TfLiteBufferHandle , tensor : * mut root :: TfLiteTensor) -> root :: TfLiteStatus > , # [doc = " Free the Delegate Buffer Handle. Note: This only frees the handle, but\n this doesn't release the underlying resource (e.g. textures). The\n resources are either owned by application layer or the delegate.\n This can be null if the delegate doesn't use its own buffer."] pub FreeBufferHandle : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , delegate : * mut root :: TfLiteDelegate , handle : * mut root :: TfLiteBufferHandle) > , # [doc = " Bitmask flags. See the comments in `TfLiteDelegateFlags`."] pub flags : i64 , # [doc = " The opaque delegate builder associated with this object.  If set then the\n TF Lite runtime will give precedence to this field.  E.g. instead of\n invoking `Prepare` via the function pointer inside the `TfLiteDelegate`\n object, the runtime will first check if the corresponding function\n pointer inside `opaque_delegate_builder` is set and if so invoke that.\n\n If this field is non-null, then the `Prepare` field (of the\n `TfLiteDelegate`) should be null."] pub opaque_delegate_builder : * mut root :: TfLiteOpaqueDelegateBuilder , } impl Default for TfLiteDelegate { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " `TfLiteOpaqueDelegateBuilder` is used for constructing\n `TfLiteOpaqueDelegate`, see `TfLiteOpaqueDelegateCreate` in c_api_opaque.h.\n NOTE: This struct is not ABI stable.\n\n For forward source compatibility `TfLiteOpaqueDelegateBuilder` objects\n should be brace-initialized, so that all fields (including any that might be\n added in the future) get zero-initialized.  The purpose of each field is\n exactly the same as with `TfLiteDelegate`.\n\n NOTE: This type is part of the TensorFlow Lite Extension APIs.\n We reserve the right to make changes to this API in future releases,\n potentially including non-backwards-compatible changes, on a different\n schedule than for the other TensorFlow Lite APIs. See\n https://www.tensorflow.org/guide/versions#separate_version_number_for_tensorflow_lite_extension_apis."] # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TfLiteOpaqueDelegateBuilder { # [doc = " Data that delegate needs to identify itself. This data is owned by the\n delegate. The delegate is owned in the user code, so the delegate is\n responsible for deallocating this when it is destroyed."] pub data : * mut cty :: c_void , # [doc = " Invoked by ModifyGraphWithDelegate. This prepare is called, giving the\n delegate a view of the current graph through `TfLiteContext*`. It\n typically will look at the nodes and call\n `ReplaceNodeSubsetsWithDelegateKernels()` to ask the TensorFlow lite\n runtime to create macro-nodes to represent delegated subgraphs of the\n original graph."] pub Prepare : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteOpaqueContext , delegate : * mut root :: TfLiteOpaqueDelegate , data : * mut cty :: c_void) -> root :: TfLiteStatus > , # [doc = " Copies the data from delegate buffer handle into raw memory of the given\n `tensor`. Note that the delegate is allowed to allocate the raw bytes as\n long as it follows the rules for kTfLiteDynamic tensors, in which case\n this cannot be null."] pub CopyFromBufferHandle : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteOpaqueContext , delegate : * mut root :: TfLiteOpaqueDelegate , data : * mut cty :: c_void , buffer_handle : root :: TfLiteBufferHandle , tensor : * mut root :: TfLiteOpaqueTensor) -> root :: TfLiteStatus > , # [doc = " Copies the data from raw memory of the given `tensor` to delegate buffer\n handle. This can be null if the delegate doesn't use its own buffer."] pub CopyToBufferHandle : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteOpaqueContext , delegate : * mut root :: TfLiteOpaqueDelegate , data : * mut cty :: c_void , buffer_handle : root :: TfLiteBufferHandle , tensor : * mut root :: TfLiteOpaqueTensor) -> root :: TfLiteStatus > , # [doc = " Frees the Delegate Buffer Handle. Note: This only frees the handle, but\n this doesn't release the underlying resource (e.g. textures). The\n resources are either owned by application layer or the delegate.\n This can be null if the delegate doesn't use its own buffer."] pub FreeBufferHandle : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteOpaqueContext , delegate : * mut root :: TfLiteOpaqueDelegate , data : * mut cty :: c_void , handle : * mut root :: TfLiteBufferHandle) > , # [doc = " Bitmask flags. See the comments in `TfLiteDelegateFlags`."] pub flags : i64 , } impl Default for TfLiteOpaqueDelegateBuilder { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } pub mod tflite { # [allow (unused_imports)] use self :: super :: super :: root ; } # [repr (C)] # [derive (Debug , Copy , Clone , PartialEq , Eq)] pub struct TFLMRegistration { pub init : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , buffer : * const cty :: c_char , length : usize) -> * mut cty :: c_void > , pub free : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , buffer : * mut cty :: c_void) > , pub prepare : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , node : * mut root :: TfLiteNode) -> root :: TfLiteStatus > , pub invoke : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , node : * mut root :: TfLiteNode) -> root :: TfLiteStatus > , pub reset : :: core :: option :: Option < unsafe extern "C" fn (context : * mut root :: TfLiteContext , buffer : * mut cty :: c_void) > , pub builtin_code : i32 , pub custom_name : * const cty :: c_char , } impl Default for TFLMRegistration { fn default () -> Self { let mut s = :: core :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: core :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct MicroInterpreter { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct Model { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct MicroMutableOpResolver { _unused : [u8 ; 0] , } pub const AddAbs : root :: AddableResolver = 0 ; pub const AddAdd : root :: AddableResolver = 1 ; pub const AddAddN : root :: AddableResolver = 2 ; pub const AddArgMax : root :: AddableResolver = 3 ; pub const AddArgMin : root :: AddableResolver = 4 ; pub const AddAssignVariable : root :: AddableResolver = 5 ; pub const AddAveragePool2D : root :: AddableResolver = 6 ; pub const AddBatchMatMul : root :: AddableResolver = 7 ; pub const AddBatchToSpaceNd : root :: AddableResolver = 8 ; pub const AddBroadcastArgs : root :: AddableResolver = 9 ; pub const AddBroadcastTo : root :: AddableResolver = 10 ; pub const AddCallOnce : root :: AddableResolver = 11 ; pub const AddCast : root :: AddableResolver = 12 ; pub const AddCeil : root :: AddableResolver = 13 ; pub const AddCircularBuffer : root :: AddableResolver = 14 ; pub const AddConcatenation : root :: AddableResolver = 15 ; pub const AddConv2D : root :: AddableResolver = 16 ; pub const AddCos : root :: AddableResolver = 17 ; pub const AddCumSum : root :: AddableResolver = 18 ; pub const AddDelay : root :: AddableResolver = 19 ; pub const AddDepthToSpace : root :: AddableResolver = 20 ; pub const AddDepthwiseConv2D : root :: AddableResolver = 21 ; pub const AddDequantize : root :: AddableResolver = 22 ; pub const AddDetectionPostprocess : root :: AddableResolver = 23 ; pub const AddDiv : root :: AddableResolver = 24 ; pub const AddEmbeddingLookup : root :: AddableResolver = 25 ; pub const AddEnergy : root :: AddableResolver = 26 ; pub const AddElu : root :: AddableResolver = 27 ; pub const AddEqual : root :: AddableResolver = 28 ; pub const AddEthosU : root :: AddableResolver = 29 ; pub const AddExp : root :: AddableResolver = 30 ; pub const AddExpandDims : root :: AddableResolver = 31 ; pub const AddFftAutoScale : root :: AddableResolver = 32 ; pub const AddFill : root :: AddableResolver = 33 ; pub const AddFilterBank : root :: AddableResolver = 34 ; pub const AddFilterBankLog : root :: AddableResolver = 35 ; pub const AddFilterBankSquareRoot : root :: AddableResolver = 36 ; pub const AddFilterBankSpectralSubtraction : root :: AddableResolver = 37 ; pub const AddFloor : root :: AddableResolver = 38 ; pub const AddFloorDiv : root :: AddableResolver = 39 ; pub const AddFloorMod : root :: AddableResolver = 40 ; pub const AddFramer : root :: AddableResolver = 41 ; pub const AddFullyConnected : root :: AddableResolver = 42 ; pub const AddGather : root :: AddableResolver = 43 ; pub const AddGatherNd : root :: AddableResolver = 44 ; pub const AddGreater : root :: AddableResolver = 45 ; pub const AddGreaterEqual : root :: AddableResolver = 46 ; pub const AddHardSwish : root :: AddableResolver = 47 ; pub const AddIf : root :: AddableResolver = 48 ; pub const AddIrfft : root :: AddableResolver = 49 ; pub const AddL2Normalization : root :: AddableResolver = 50 ; pub const AddL2Pool2D : root :: AddableResolver = 51 ; pub const AddLeakyRelu : root :: AddableResolver = 52 ; pub const AddLess : root :: AddableResolver = 53 ; pub const AddLessEqual : root :: AddableResolver = 54 ; pub const AddLog : root :: AddableResolver = 55 ; pub const AddLogicalAnd : root :: AddableResolver = 56 ; pub const AddLogicalNot : root :: AddableResolver = 57 ; pub const AddLogicalOr : root :: AddableResolver = 58 ; pub const AddLogistic : root :: AddableResolver = 59 ; pub const AddLogSoftmax : root :: AddableResolver = 60 ; pub const AddMaximum : root :: AddableResolver = 61 ; pub const AddMaxPool2D : root :: AddableResolver = 62 ; pub const AddMirrorPad : root :: AddableResolver = 63 ; pub const AddMean : root :: AddableResolver = 64 ; pub const AddMinimum : root :: AddableResolver = 65 ; pub const AddMul : root :: AddableResolver = 66 ; pub const AddNeg : root :: AddableResolver = 67 ; pub const AddNotEqual : root :: AddableResolver = 68 ; pub const AddOverlapAdd : root :: AddableResolver = 69 ; pub const AddPack : root :: AddableResolver = 70 ; pub const AddPad : root :: AddableResolver = 71 ; pub const AddPadV2 : root :: AddableResolver = 72 ; pub const AddPCAN : root :: AddableResolver = 73 ; pub const AddPrelu : root :: AddableResolver = 74 ; pub const AddQuantize : root :: AddableResolver = 75 ; pub const AddReadVariable : root :: AddableResolver = 76 ; pub const AddReduceMax : root :: AddableResolver = 77 ; pub const AddRelu : root :: AddableResolver = 78 ; pub const AddRelu6 : root :: AddableResolver = 79 ; pub const AddReshape : root :: AddableResolver = 80 ; pub const AddResizeBilinear : root :: AddableResolver = 81 ; pub const AddResizeNearestNeighbor : root :: AddableResolver = 82 ; pub const AddRfft : root :: AddableResolver = 83 ; pub const AddRound : root :: AddableResolver = 84 ; pub const AddRsqrt : root :: AddableResolver = 85 ; pub const AddSelectV2 : root :: AddableResolver = 86 ; pub const AddShape : root :: AddableResolver = 87 ; pub const AddSin : root :: AddableResolver = 88 ; pub const AddSlice : root :: AddableResolver = 89 ; pub const AddSoftmax : root :: AddableResolver = 90 ; pub const AddSpaceToBatchNd : root :: AddableResolver = 91 ; pub const AddSpaceToDepth : root :: AddableResolver = 92 ; pub const AddSplit : root :: AddableResolver = 93 ; pub const AddSplitV : root :: AddableResolver = 94 ; pub const AddSqueeze : root :: AddableResolver = 95 ; pub const AddSqrt : root :: AddableResolver = 96 ; pub const AddSquare : root :: AddableResolver = 97 ; pub const AddSquaredDifference : root :: AddableResolver = 98 ; pub const AddStridedSlice : root :: AddableResolver = 99 ; pub const AddStacker : root :: AddableResolver = 100 ; pub const AddSub : root :: AddableResolver = 101 ; pub const AddSum : root :: AddableResolver = 102 ; pub const AddSvdf : root :: AddableResolver = 103 ; pub const AddTanh : root :: AddableResolver = 104 ; pub const AddTransposeConv : root :: AddableResolver = 105 ; pub const AddTranspose : root :: AddableResolver = 106 ; pub const AddUnpack : root :: AddableResolver = 107 ; pub const AddUnidirectionalSequenceLSTM : root :: AddableResolver = 108 ; pub const AddVarHandle : root :: AddableResolver = 109 ; pub const AddWhile : root :: AddableResolver = 110 ; pub const AddWindow : root :: AddableResolver = 111 ; pub const AddZerosLike : root :: AddableResolver = 112 ; pub type AddableResolver = cty :: c_uint ; extern "C" { pub fn getModel (buffer : * const cty :: c_void , len : usize) -> * const root :: Model ; } extern "C" { pub fn destroyModel (model : * const root :: Model) ; } extern "C" { pub fn getInterpreter (model : * const root :: Model , resolver : * mut root :: MicroMutableOpResolver , kTensorArenaSize : cty :: c_int) -> * mut root :: MicroInterpreter ; } extern "C" { pub fn destroyInterpreter (interpreter : * mut root :: MicroInterpreter) ; } extern "C" { pub fn allocateTensors (interpreter : * mut root :: MicroInterpreter) -> root :: TfLiteStatus ; } extern "C" { pub fn createEmptyResolver () -> * mut root :: MicroMutableOpResolver ; } extern "C" { pub fn destroyResolver (resolver : * mut root :: MicroMutableOpResolver) ; } extern "C" { pub fn addCustomResolver (resolver : * mut root :: MicroMutableOpResolver , name : * mut cty :: c_char , registration : * mut root :: TFLMRegistration) -> root :: TfLiteStatus ; } extern "C" { pub fn addResolver (resolver : * mut root :: MicroMutableOpResolver , resolverToAdd : root :: AddableResolver) -> root :: TfLiteStatus ; } extern "C" { pub fn getTensorInput (interpreter : * mut root :: MicroInterpreter , n : usize) -> * mut root :: TfLiteTensor ; } extern "C" { pub fn invokeInterpreter (interpreter : * mut root :: MicroInterpreter) -> root :: TfLiteStatus ; } extern "C" { pub fn getTensorOutput (interpreter : * mut root :: MicroInterpreter , n : usize) -> * mut root :: TfLiteTensor ; } # [doc = " Retrieves asynchronous kernel.\n\n If the `async_kernel` field is nullptr, it means the operation described\n by this TfLiteRegistration object does not support asynchronous execution.\n Otherwise, the function that the field points to should only be called for\n delegate kernel nodes, i.e. `node` should be a delegate kernel node\n created by applying a delegate. If the function returns nullptr, that\n means that the underlying delegate does not support asynchronous execution\n for this `node`."] # [repr (C)] # [derive (Debug , Default , Copy , Clone , PartialEq , Eq)] pub struct TfLiteAsyncKernel { pub _address : u8 , } }